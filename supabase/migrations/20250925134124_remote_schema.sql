revoke delete on table "public"."annual_production_summary" from "anon";

revoke insert on table "public"."annual_production_summary" from "anon";

revoke references on table "public"."annual_production_summary" from "anon";

revoke select on table "public"."annual_production_summary" from "anon";

revoke trigger on table "public"."annual_production_summary" from "anon";

revoke truncate on table "public"."annual_production_summary" from "anon";

revoke update on table "public"."annual_production_summary" from "anon";

revoke delete on table "public"."annual_production_summary" from "authenticated";

revoke insert on table "public"."annual_production_summary" from "authenticated";

revoke references on table "public"."annual_production_summary" from "authenticated";

revoke select on table "public"."annual_production_summary" from "authenticated";

revoke trigger on table "public"."annual_production_summary" from "authenticated";

revoke truncate on table "public"."annual_production_summary" from "authenticated";

revoke update on table "public"."annual_production_summary" from "authenticated";

revoke delete on table "public"."annual_production_summary" from "service_role";

revoke insert on table "public"."annual_production_summary" from "service_role";

revoke references on table "public"."annual_production_summary" from "service_role";

revoke select on table "public"."annual_production_summary" from "service_role";

revoke trigger on table "public"."annual_production_summary" from "service_role";

revoke truncate on table "public"."annual_production_summary" from "service_role";

revoke update on table "public"."annual_production_summary" from "service_role";

revoke delete on table "public"."cal_contest_periods" from "anon";

revoke insert on table "public"."cal_contest_periods" from "anon";

revoke references on table "public"."cal_contest_periods" from "anon";

revoke select on table "public"."cal_contest_periods" from "anon";

revoke trigger on table "public"."cal_contest_periods" from "anon";

revoke truncate on table "public"."cal_contest_periods" from "anon";

revoke update on table "public"."cal_contest_periods" from "anon";

revoke delete on table "public"."cal_contest_periods" from "authenticated";

revoke insert on table "public"."cal_contest_periods" from "authenticated";

revoke references on table "public"."cal_contest_periods" from "authenticated";

revoke select on table "public"."cal_contest_periods" from "authenticated";

revoke trigger on table "public"."cal_contest_periods" from "authenticated";

revoke truncate on table "public"."cal_contest_periods" from "authenticated";

revoke update on table "public"."cal_contest_periods" from "authenticated";

revoke delete on table "public"."cal_contest_periods" from "service_role";

revoke insert on table "public"."cal_contest_periods" from "service_role";

revoke references on table "public"."cal_contest_periods" from "service_role";

revoke select on table "public"."cal_contest_periods" from "service_role";

revoke trigger on table "public"."cal_contest_periods" from "service_role";

revoke truncate on table "public"."cal_contest_periods" from "service_role";

revoke update on table "public"."cal_contest_periods" from "service_role";

revoke delete on table "public"."cal_systems_closing_periods" from "anon";

revoke insert on table "public"."cal_systems_closing_periods" from "anon";

revoke references on table "public"."cal_systems_closing_periods" from "anon";

revoke select on table "public"."cal_systems_closing_periods" from "anon";

revoke trigger on table "public"."cal_systems_closing_periods" from "anon";

revoke truncate on table "public"."cal_systems_closing_periods" from "anon";

revoke update on table "public"."cal_systems_closing_periods" from "anon";

revoke delete on table "public"."cal_systems_closing_periods" from "authenticated";

revoke insert on table "public"."cal_systems_closing_periods" from "authenticated";

revoke references on table "public"."cal_systems_closing_periods" from "authenticated";

revoke select on table "public"."cal_systems_closing_periods" from "authenticated";

revoke trigger on table "public"."cal_systems_closing_periods" from "authenticated";

revoke truncate on table "public"."cal_systems_closing_periods" from "authenticated";

revoke update on table "public"."cal_systems_closing_periods" from "authenticated";

revoke delete on table "public"."cal_systems_closing_periods" from "service_role";

revoke insert on table "public"."cal_systems_closing_periods" from "service_role";

revoke references on table "public"."cal_systems_closing_periods" from "service_role";

revoke select on table "public"."cal_systems_closing_periods" from "service_role";

revoke trigger on table "public"."cal_systems_closing_periods" from "service_role";

revoke truncate on table "public"."cal_systems_closing_periods" from "service_role";

revoke update on table "public"."cal_systems_closing_periods" from "service_role";

revoke delete on table "public"."fy_commission_details" from "anon";

revoke insert on table "public"."fy_commission_details" from "anon";

revoke references on table "public"."fy_commission_details" from "anon";

revoke select on table "public"."fy_commission_details" from "anon";

revoke trigger on table "public"."fy_commission_details" from "anon";

revoke truncate on table "public"."fy_commission_details" from "anon";

revoke update on table "public"."fy_commission_details" from "anon";

revoke delete on table "public"."fy_commission_details" from "authenticated";

revoke insert on table "public"."fy_commission_details" from "authenticated";

revoke references on table "public"."fy_commission_details" from "authenticated";

revoke select on table "public"."fy_commission_details" from "authenticated";

revoke trigger on table "public"."fy_commission_details" from "authenticated";

revoke truncate on table "public"."fy_commission_details" from "authenticated";

revoke update on table "public"."fy_commission_details" from "authenticated";

revoke delete on table "public"."fy_commission_details" from "service_role";

revoke insert on table "public"."fy_commission_details" from "service_role";

revoke references on table "public"."fy_commission_details" from "service_role";

revoke select on table "public"."fy_commission_details" from "service_role";

revoke trigger on table "public"."fy_commission_details" from "service_role";

revoke truncate on table "public"."fy_commission_details" from "service_role";

revoke update on table "public"."fy_commission_details" from "service_role";

revoke delete on table "public"."leads" from "anon";

revoke insert on table "public"."leads" from "anon";

revoke references on table "public"."leads" from "anon";

revoke select on table "public"."leads" from "anon";

revoke trigger on table "public"."leads" from "anon";

revoke truncate on table "public"."leads" from "anon";

revoke update on table "public"."leads" from "anon";

revoke delete on table "public"."leads" from "authenticated";

revoke insert on table "public"."leads" from "authenticated";

revoke references on table "public"."leads" from "authenticated";

revoke select on table "public"."leads" from "authenticated";

revoke trigger on table "public"."leads" from "authenticated";

revoke truncate on table "public"."leads" from "authenticated";

revoke update on table "public"."leads" from "authenticated";

revoke delete on table "public"."leads" from "service_role";

revoke insert on table "public"."leads" from "service_role";

revoke references on table "public"."leads" from "service_role";

revoke select on table "public"."leads" from "service_role";

revoke trigger on table "public"."leads" from "service_role";

revoke truncate on table "public"."leads" from "service_role";

revoke update on table "public"."leads" from "service_role";

revoke delete on table "public"."manpower" from "anon";

revoke insert on table "public"."manpower" from "anon";

revoke references on table "public"."manpower" from "anon";

revoke select on table "public"."manpower" from "anon";

revoke trigger on table "public"."manpower" from "anon";

revoke truncate on table "public"."manpower" from "anon";

revoke update on table "public"."manpower" from "anon";

revoke delete on table "public"."manpower" from "authenticated";

revoke insert on table "public"."manpower" from "authenticated";

revoke references on table "public"."manpower" from "authenticated";

revoke select on table "public"."manpower" from "authenticated";

revoke trigger on table "public"."manpower" from "authenticated";

revoke truncate on table "public"."manpower" from "authenticated";

revoke update on table "public"."manpower" from "authenticated";

revoke delete on table "public"."manpower" from "service_role";

revoke insert on table "public"."manpower" from "service_role";

revoke references on table "public"."manpower" from "service_role";

revoke select on table "public"."manpower" from "service_role";

revoke trigger on table "public"."manpower" from "service_role";

revoke truncate on table "public"."manpower" from "service_role";

revoke update on table "public"."manpower" from "service_role";

revoke delete on table "public"."monthly_production_summary" from "anon";

revoke insert on table "public"."monthly_production_summary" from "anon";

revoke references on table "public"."monthly_production_summary" from "anon";

revoke select on table "public"."monthly_production_summary" from "anon";

revoke trigger on table "public"."monthly_production_summary" from "anon";

revoke truncate on table "public"."monthly_production_summary" from "anon";

revoke update on table "public"."monthly_production_summary" from "anon";

revoke delete on table "public"."monthly_production_summary" from "authenticated";

revoke insert on table "public"."monthly_production_summary" from "authenticated";

revoke references on table "public"."monthly_production_summary" from "authenticated";

revoke select on table "public"."monthly_production_summary" from "authenticated";

revoke trigger on table "public"."monthly_production_summary" from "authenticated";

revoke truncate on table "public"."monthly_production_summary" from "authenticated";

revoke update on table "public"."monthly_production_summary" from "authenticated";

revoke delete on table "public"."monthly_production_summary" from "service_role";

revoke insert on table "public"."monthly_production_summary" from "service_role";

revoke references on table "public"."monthly_production_summary" from "service_role";

revoke select on table "public"."monthly_production_summary" from "service_role";

revoke trigger on table "public"."monthly_production_summary" from "service_role";

revoke truncate on table "public"."monthly_production_summary" from "service_role";

revoke update on table "public"."monthly_production_summary" from "service_role";

revoke delete on table "public"."profiles" from "anon";

revoke insert on table "public"."profiles" from "anon";

revoke references on table "public"."profiles" from "anon";

revoke select on table "public"."profiles" from "anon";

revoke trigger on table "public"."profiles" from "anon";

revoke truncate on table "public"."profiles" from "anon";

revoke update on table "public"."profiles" from "anon";

revoke delete on table "public"."profiles" from "authenticated";

revoke insert on table "public"."profiles" from "authenticated";

revoke references on table "public"."profiles" from "authenticated";

revoke select on table "public"."profiles" from "authenticated";

revoke trigger on table "public"."profiles" from "authenticated";

revoke truncate on table "public"."profiles" from "authenticated";

revoke update on table "public"."profiles" from "authenticated";

revoke delete on table "public"."profiles" from "service_role";

revoke insert on table "public"."profiles" from "service_role";

revoke references on table "public"."profiles" from "service_role";

revoke select on table "public"."profiles" from "service_role";

revoke trigger on table "public"."profiles" from "service_role";

revoke truncate on table "public"."profiles" from "service_role";

revoke update on table "public"."profiles" from "service_role";

revoke delete on table "public"."rn_commission_details" from "anon";

revoke insert on table "public"."rn_commission_details" from "anon";

revoke references on table "public"."rn_commission_details" from "anon";

revoke select on table "public"."rn_commission_details" from "anon";

revoke trigger on table "public"."rn_commission_details" from "anon";

revoke truncate on table "public"."rn_commission_details" from "anon";

revoke update on table "public"."rn_commission_details" from "anon";

revoke delete on table "public"."rn_commission_details" from "authenticated";

revoke insert on table "public"."rn_commission_details" from "authenticated";

revoke references on table "public"."rn_commission_details" from "authenticated";

revoke select on table "public"."rn_commission_details" from "authenticated";

revoke trigger on table "public"."rn_commission_details" from "authenticated";

revoke truncate on table "public"."rn_commission_details" from "authenticated";

revoke update on table "public"."rn_commission_details" from "authenticated";

revoke delete on table "public"."rn_commission_details" from "service_role";

revoke insert on table "public"."rn_commission_details" from "service_role";

revoke references on table "public"."rn_commission_details" from "service_role";

revoke select on table "public"."rn_commission_details" from "service_role";

revoke trigger on table "public"."rn_commission_details" from "service_role";

revoke truncate on table "public"."rn_commission_details" from "service_role";

revoke update on table "public"."rn_commission_details" from "service_role";

revoke delete on table "public"."settled_apps_details" from "anon";

revoke insert on table "public"."settled_apps_details" from "anon";

revoke references on table "public"."settled_apps_details" from "anon";

revoke select on table "public"."settled_apps_details" from "anon";

revoke trigger on table "public"."settled_apps_details" from "anon";

revoke truncate on table "public"."settled_apps_details" from "anon";

revoke update on table "public"."settled_apps_details" from "anon";

revoke delete on table "public"."settled_apps_details" from "authenticated";

revoke insert on table "public"."settled_apps_details" from "authenticated";

revoke references on table "public"."settled_apps_details" from "authenticated";

revoke select on table "public"."settled_apps_details" from "authenticated";

revoke trigger on table "public"."settled_apps_details" from "authenticated";

revoke truncate on table "public"."settled_apps_details" from "authenticated";

revoke update on table "public"."settled_apps_details" from "authenticated";

revoke delete on table "public"."settled_apps_details" from "service_role";

revoke insert on table "public"."settled_apps_details" from "service_role";

revoke references on table "public"."settled_apps_details" from "service_role";

revoke select on table "public"."settled_apps_details" from "service_role";

revoke trigger on table "public"."settled_apps_details" from "service_role";

revoke truncate on table "public"."settled_apps_details" from "service_role";

revoke update on table "public"."settled_apps_details" from "service_role";

revoke delete on table "public"."staff" from "anon";

revoke insert on table "public"."staff" from "anon";

revoke references on table "public"."staff" from "anon";

revoke select on table "public"."staff" from "anon";

revoke trigger on table "public"."staff" from "anon";

revoke truncate on table "public"."staff" from "anon";

revoke update on table "public"."staff" from "anon";

revoke delete on table "public"."staff" from "authenticated";

revoke insert on table "public"."staff" from "authenticated";

revoke references on table "public"."staff" from "authenticated";

revoke select on table "public"."staff" from "authenticated";

revoke trigger on table "public"."staff" from "authenticated";

revoke truncate on table "public"."staff" from "authenticated";

revoke update on table "public"."staff" from "authenticated";

revoke delete on table "public"."staff" from "service_role";

revoke insert on table "public"."staff" from "service_role";

revoke references on table "public"."staff" from "service_role";

revoke select on table "public"."staff" from "service_role";

revoke trigger on table "public"."staff" from "service_role";

revoke truncate on table "public"."staff" from "service_role";

revoke update on table "public"."staff" from "service_role";

revoke delete on table "public"."staff_advisor_assignments" from "anon";

revoke insert on table "public"."staff_advisor_assignments" from "anon";

revoke references on table "public"."staff_advisor_assignments" from "anon";

revoke select on table "public"."staff_advisor_assignments" from "anon";

revoke trigger on table "public"."staff_advisor_assignments" from "anon";

revoke truncate on table "public"."staff_advisor_assignments" from "anon";

revoke update on table "public"."staff_advisor_assignments" from "anon";

revoke delete on table "public"."staff_advisor_assignments" from "authenticated";

revoke insert on table "public"."staff_advisor_assignments" from "authenticated";

revoke references on table "public"."staff_advisor_assignments" from "authenticated";

revoke select on table "public"."staff_advisor_assignments" from "authenticated";

revoke trigger on table "public"."staff_advisor_assignments" from "authenticated";

revoke truncate on table "public"."staff_advisor_assignments" from "authenticated";

revoke update on table "public"."staff_advisor_assignments" from "authenticated";

revoke delete on table "public"."staff_advisor_assignments" from "service_role";

revoke insert on table "public"."staff_advisor_assignments" from "service_role";

revoke references on table "public"."staff_advisor_assignments" from "service_role";

revoke select on table "public"."staff_advisor_assignments" from "service_role";

revoke trigger on table "public"."staff_advisor_assignments" from "service_role";

revoke truncate on table "public"."staff_advisor_assignments" from "service_role";

revoke update on table "public"."staff_advisor_assignments" from "service_role";

revoke delete on table "public"."submitted_apps_details" from "anon";

revoke insert on table "public"."submitted_apps_details" from "anon";

revoke references on table "public"."submitted_apps_details" from "anon";

revoke select on table "public"."submitted_apps_details" from "anon";

revoke trigger on table "public"."submitted_apps_details" from "anon";

revoke truncate on table "public"."submitted_apps_details" from "anon";

revoke update on table "public"."submitted_apps_details" from "anon";

revoke delete on table "public"."submitted_apps_details" from "authenticated";

revoke insert on table "public"."submitted_apps_details" from "authenticated";

revoke references on table "public"."submitted_apps_details" from "authenticated";

revoke select on table "public"."submitted_apps_details" from "authenticated";

revoke trigger on table "public"."submitted_apps_details" from "authenticated";

revoke truncate on table "public"."submitted_apps_details" from "authenticated";

revoke update on table "public"."submitted_apps_details" from "authenticated";

revoke delete on table "public"."submitted_apps_details" from "service_role";

revoke insert on table "public"."submitted_apps_details" from "service_role";

revoke references on table "public"."submitted_apps_details" from "service_role";

revoke select on table "public"."submitted_apps_details" from "service_role";

revoke trigger on table "public"."submitted_apps_details" from "service_role";

revoke truncate on table "public"."submitted_apps_details" from "service_role";

revoke update on table "public"."submitted_apps_details" from "service_role";

revoke delete on table "public"."teams" from "anon";

revoke insert on table "public"."teams" from "anon";

revoke references on table "public"."teams" from "anon";

revoke select on table "public"."teams" from "anon";

revoke trigger on table "public"."teams" from "anon";

revoke truncate on table "public"."teams" from "anon";

revoke update on table "public"."teams" from "anon";

revoke delete on table "public"."teams" from "authenticated";

revoke insert on table "public"."teams" from "authenticated";

revoke references on table "public"."teams" from "authenticated";

revoke select on table "public"."teams" from "authenticated";

revoke trigger on table "public"."teams" from "authenticated";

revoke truncate on table "public"."teams" from "authenticated";

revoke update on table "public"."teams" from "authenticated";

revoke delete on table "public"."teams" from "service_role";

revoke insert on table "public"."teams" from "service_role";

revoke references on table "public"."teams" from "service_role";

revoke select on table "public"."teams" from "service_role";

revoke trigger on table "public"."teams" from "service_role";

revoke truncate on table "public"."teams" from "service_role";

revoke update on table "public"."teams" from "service_role";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.admin_assign_staff_to_advisor(target_staff_id uuid, target_advisor_code text, assignment_notes text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  assignment_id uuid;
  staff_name text;
  advisor_name text;
begin
  -- Security check: only admin can make assignments
  if public.get_user_app_role(auth.uid()) != 'admin' then
    raise exception 'Access denied: Only admin users can assign staff to advisors';
  end if;

  -- Validate inputs
  if not exists(select 1 from public.staff where id = target_staff_id) then
    raise exception 'Staff record with ID % does not exist', target_staff_id;
  end if;

  if not exists(select 1 from public.manpower where code_number = target_advisor_code) then
    raise exception 'Advisor with code % does not exist', target_advisor_code;
  end if;

  -- Check if assignment already exists and is active
  if exists(
    select 1 from public.staff_advisor_assignments
    where staff_id = target_staff_id
      and advisor_code_number = target_advisor_code
      and active = true
  ) then
    raise exception 'Staff is already assigned to advisor %', target_advisor_code;
  end if;

  -- Get names for response
  select staff_name into staff_name from public.staff where id = target_staff_id;
  select advisor_name into advisor_name from public.manpower where code_number = target_advisor_code;

  -- Create the assignment
  insert into public.staff_advisor_assignments (
    staff_id,
    advisor_code_number,
    assigned_at,
    created_by,
    active,
    notes
  ) values (
    target_staff_id,
    target_advisor_code,
    now(),
    auth.uid(),
    true,
    assignment_notes
  ) returning id into assignment_id;

  return json_build_object(
    'success', true,
    'message', 'Staff successfully assigned to advisor',
    'assignment_id', assignment_id,
    'staff_id', target_staff_id,
    'staff_name', staff_name,
    'advisor_code', target_advisor_code,
    'advisor_name', advisor_name,
    'assigned_at', now(),
    'notes', assignment_notes
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.admin_bulk_assign_staff(target_staff_id uuid, advisor_codes text[], assignment_notes text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  advisor_code text;
  assignment_id uuid;
  assignment_ids uuid[] := '{}';
  success_count integer := 0;
  error_count integer := 0;
  errors text[] := '{}';
begin
  -- Security check
  if public.get_user_app_role(auth.uid()) != 'admin' then
    raise exception 'Access denied: Only admin users can make bulk assignments';
  end if;

  -- Validate staff exists
  if not exists(select 1 from public.staff where id = target_staff_id) then
    raise exception 'Staff record with ID % does not exist', target_staff_id;
  end if;

  -- Process each advisor code
  foreach advisor_code in array advisor_codes
  loop
    begin
      -- Try to create assignment
      insert into public.staff_advisor_assignments (
        staff_id,
        advisor_code_number,
        assigned_at,
        created_by,
        active,
        notes
      ) values (
        target_staff_id,
        advisor_code,
        now(),
        auth.uid(),
        true,
        assignment_notes
      ) returning id into assignment_id;

      assignment_ids := assignment_ids || assignment_id;
      success_count := success_count + 1;

    exception when others then
      error_count := error_count + 1;
      errors := errors || (advisor_code || ': ' || SQLERRM);
    end;
  end loop;

  return json_build_object(
    'success', success_count > 0,
    'message', format('Bulk assignment completed: %s successes, %s errors', success_count, error_count),
    'assignment_ids', assignment_ids,
    'success_count', success_count,
    'error_count', error_count,
    'errors', errors
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.admin_get_user_details(target_user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  profile_record record;
  manpower_record record;
  staff_record record;
  assignments_json json;
begin
  -- Security check
  if public.get_user_app_role(auth.uid()) != 'admin' then
    raise exception 'Access denied: Only admin users can access detailed user information';
  end if;

  -- Get profile info
  select * into profile_record from public.profiles where user_id = target_user_id;

  -- Get manpower info if linked
  select * into manpower_record from public.manpower where profile_user_id = target_user_id;

  -- Get staff info if linked
  select * into staff_record from public.staff where profile_user_id = target_user_id;

  -- Get staff assignments if they are staff
  if staff_record.id is not null then
    select json_agg(
      json_build_object(
        'assignment_id', saa.id,
        'advisor_code', saa.advisor_code_number,
        'advisor_name', m.advisor_name,
        'assigned_at', saa.assigned_at,
        'active', saa.active,
        'notes', saa.notes
      )
    ) into assignments_json
    from public.staff_advisor_assignments saa
    left join public.manpower m on saa.advisor_code_number = m.code_number
    where saa.staff_id = staff_record.id;
  end if;

  return json_build_object(
    'user_id', target_user_id,
    'profile', row_to_json(profile_record),
    'manpower', row_to_json(manpower_record),
    'staff', row_to_json(staff_record),
    'assignments', coalesce(assignments_json, '[]'::json)
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.admin_link_user_to_manpower(target_user_id uuid, target_code_number text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  result_record record;
begin
  -- Security check: only admin can link users
  if public.get_user_app_role(auth.uid()) != 'admin' then
    raise exception 'Access denied: Only admin users can link users to manpower records';
  end if;

  -- Validate that the user exists
  if not public.is_user_active(target_user_id) then
    raise exception 'User with ID % does not exist or is not active', target_user_id;
  end if;

  -- Validate that the manpower record exists
  if not exists(select 1 from public.manpower where code_number = target_code_number) then
    raise exception 'Manpower record with code % does not exist', target_code_number;
  end if;

  -- Check if user is already linked to another manpower record
  if exists(select 1 from public.manpower where profile_user_id = target_user_id) then
    raise exception 'User is already linked to a manpower record. Unlink first if needed.';
  end if;

  -- Check if manpower record is already linked to another user
  if exists(select 1 from public.manpower where code_number = target_code_number and profile_user_id is not null) then
    raise exception 'Manpower record % is already linked to another user', target_code_number;
  end if;

  -- Perform the linking
  update public.manpower
  set profile_user_id = target_user_id,
      updated_at = now()
  where code_number = target_code_number
  returning * into result_record;

  -- Return success response
  return json_build_object(
    'success', true,
    'message', 'User successfully linked to manpower record',
    'user_id', target_user_id,
    'code_number', target_code_number,
    'linked_at', now()
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.admin_link_user_to_staff(target_user_id uuid, target_staff_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  -- Security check: only admin can link users
  if public.get_user_app_role(auth.uid()) != 'admin' then
    raise exception 'Access denied: Only admin users can link users to staff records';
  end if;

  -- Validate inputs
  if not public.is_user_active(target_user_id) then
    raise exception 'User with ID % does not exist or is not active', target_user_id;
  end if;

  if not exists(select 1 from public.staff where id = target_staff_id) then
    raise exception 'Staff record with ID % does not exist', target_staff_id;
  end if;

  -- Check for existing links
  if exists(select 1 from public.staff where profile_user_id = target_user_id) then
    raise exception 'User is already linked to a staff record';
  end if;

  if exists(select 1 from public.staff where id = target_staff_id and profile_user_id is not null) then
    raise exception 'Staff record is already linked to another user';
  end if;

  -- Perform the linking
  update public.staff
  set profile_user_id = target_user_id,
      updated_at = now()
  where id = target_staff_id;

  return json_build_object(
    'success', true,
    'message', 'User successfully linked to staff record',
    'user_id', target_user_id,
    'staff_id', target_staff_id,
    'linked_at', now()
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.admin_remove_staff_assignment(assignment_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  assignment_record record;
begin
  -- Security check: only admin can remove assignments
  if public.get_user_app_role(auth.uid()) != 'admin' then
    raise exception 'Access denied: Only admin users can remove staff assignments';
  end if;

  -- Get assignment details before removing
  select * into assignment_record
  from public.staff_advisor_assignments
  where id = assignment_id and active = true;

  if not found then
    raise exception 'Active assignment with ID % not found', assignment_id;
  end if;

  -- Deactivate the assignment (soft delete)
  update public.staff_advisor_assignments
  set active = false,
      notes = coalesce(notes || ' | ', '') || 'Removed by admin on ' || now()::text
  where id = assignment_id;

  return json_build_object(
    'success', true,
    'message', 'Staff assignment successfully removed',
    'assignment_id', assignment_id,
    'staff_id', assignment_record.staff_id,
    'advisor_code', assignment_record.advisor_code_number,
    'removed_at', now()
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.admin_unlink_user_from_manpower(target_code_number text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  old_user_id uuid;
begin
  -- Security check: only admin can unlink users
  if public.get_user_app_role(auth.uid()) != 'admin' then
    raise exception 'Access denied: Only admin users can unlink users from manpower records';
  end if;

  -- Get the current linked user
  select profile_user_id into old_user_id
  from public.manpower
  where code_number = target_code_number;

  if old_user_id is null then
    raise exception 'Manpower record % is not linked to any user', target_code_number;
  end if;

  -- Perform the unlinking
  update public.manpower
  set profile_user_id = null,
      updated_at = now()
  where code_number = target_code_number;

  return json_build_object(
    'success', true,
    'message', 'User successfully unlinked from manpower record',
    'previous_user_id', old_user_id,
    'code_number', target_code_number,
    'unlinked_at', now()
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_user_owned_row(owner_user_id uuid, current_user_id uuid, operation text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  user_role app_role_type;
  owner_manpower_code text;
begin
  user_role := public.get_user_app_role(current_user_id);

  -- Admin can do everything
  if user_role = 'admin' then
    return true;
  end if;

  -- For CREATE operations, only allow creating own records (except admin)
  if operation = 'CREATE' then
    return owner_user_id = current_user_id;
  end if;

  -- For UPDATE/DELETE operations, only allow modifying own records (except admin)
  if operation in ('UPDATE', 'DELETE') then
    return owner_user_id = current_user_id;
  end if;

  -- For READ operations, apply hierarchy rules
  if operation = 'READ' then
    -- Own records
    if owner_user_id = current_user_id then
      return true;
    end if;

    -- Get owner's manpower code
    owner_manpower_code := public.get_user_manpower_code(owner_user_id);

    -- If owner has no manpower record, only they and admin can access
    if owner_manpower_code is null then
      return false;
    end if;

    -- Manager can read subordinates' data
    if user_role = 'manager' then
      return public.can_read_manpower(owner_manpower_code, current_user_id);
    end if;

    -- Staff can read assigned advisors' data
    if user_role = 'staff' then
      return exists(
        select 1 from public.get_staff_assigned_advisors(current_user_id)
        where advisor_code = owner_manpower_code
      ) or exists(
        select 1
        from public.get_staff_assigned_advisors(current_user_id) saa
        where public.is_subordinate_of(owner_manpower_code, saa.advisor_code)
      );
    end if;
  end if;

  return false;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.can_read_manpower(target_code text, current_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  user_role app_role_type;
  user_manpower_code text;
begin
  -- Get the current user's role
  user_role := public.get_user_app_role(current_user_id);

  -- Admin can read everything
  if user_role = 'admin' then
    return true;
  end if;

  -- Manager can read own record + all subordinates
  if user_role = 'manager' then
    user_manpower_code := public.get_user_manpower_code(current_user_id);

    -- Can read own record
    if user_manpower_code = target_code then
      return true;
    end if;

    -- Can read subordinates
    return public.is_subordinate_of(target_code, user_manpower_code);
  end if;

  -- Staff can read assigned advisors and their subordinates
  if user_role = 'staff' then
    -- Check if target is directly assigned
    if exists(
      select 1 from public.get_staff_assigned_advisors(current_user_id)
      where advisor_code = target_code
    ) then
      return true;
    end if;

    -- Check if target is a subordinate of any assigned advisor
    return exists(
      select 1
      from public.get_staff_assigned_advisors(current_user_id) saa
      where public.is_subordinate_of(target_code, saa.advisor_code)
    );
  end if;

  -- Advisor/Candidate can read only their own record
  if user_role in ('advisor', 'candidate') then
    user_manpower_code := public.get_user_manpower_code(current_user_id);
    return user_manpower_code = target_code;
  end if;

  -- Default: no access
  return false;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.can_read_staff_assignment(target_staff_id uuid, target_advisor_code text, current_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  user_role app_role_type;
begin
  user_role := public.get_user_app_role(current_user_id);

  -- Admin can read everything
  if user_role = 'admin' then
    return true;
  end if;

  -- Staff can read their own assignments
  if user_role = 'staff' and public.get_user_staff_id(current_user_id) = target_staff_id then
    return true;
  end if;

  -- Advisor can read assignments related to them
  if user_role in ('advisor', 'candidate') and public.get_user_manpower_code(current_user_id) = target_advisor_code then
    return true;
  end if;

  -- Manager can read assignments for their subordinates
  if user_role = 'manager' then
    return public.can_read_manpower(target_advisor_code, current_user_id);
  end if;

  return false;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.can_read_team(target_team_id uuid, current_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  user_role app_role_type;
  team_head_code text;
begin
  user_role := public.get_user_app_role(current_user_id);

  -- Admin can read everything
  if user_role = 'admin' then
    return true;
  end if;

  -- Get the team head code
  select head_manpower_code into team_head_code
  from public.teams
  where id = target_team_id;

  -- If no team head, only admin can read
  if team_head_code is null then
    return false;
  end if;

  -- Check if user can read the team head's data (which includes team access)
  return public.can_read_manpower(team_head_code, current_user_id);
end;
$function$
;

CREATE OR REPLACE FUNCTION public.can_write_manpower(target_code text, current_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  user_role app_role_type;
  user_manpower_code text;
begin
  user_role := public.get_user_app_role(current_user_id);

  -- Admin can write everything
  if user_role = 'admin' then
    return true;
  end if;

  -- Everyone else can only write to their own record
  user_manpower_code := public.get_user_manpower_code(current_user_id);
  return user_manpower_code = target_code;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_annual_summaries()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    deleted_count integer;
    cutoff_year integer;
BEGIN
    -- Calculate cutoff year (3 years ago)
    cutoff_year := EXTRACT(year FROM CURRENT_DATE) - 2;

    -- Delete old records outside 3-year window
    DELETE FROM public.annual_production_summary
    WHERE period_year < cutoff_year;

    GET DIAGNOSTICS deleted_count = ROW_COUNT;

    RETURN 'Cleaned up ' || deleted_count || ' old annual summary records before year ' || cutoff_year;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_production_summaries()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    deleted_count integer;
    cutoff_year integer;
BEGIN
    -- Calculate cutoff year (3 years ago)
    cutoff_year := EXTRACT(year FROM CURRENT_DATE) - 2;

    -- Delete old records outside 3-year window
    DELETE FROM public.monthly_production_summary
    WHERE period_year < cutoff_year;

    GET DIAGNOSTICS deleted_count = ROW_COUNT;

    RETURN 'Cleaned up ' || deleted_count || ' old production summary records before year ' || cutoff_year;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_advisor_assigned_staff(advisor_code text)
 RETURNS TABLE(staff_id uuid, staff_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return query
  select s.id, s.staff_name
  from public.staff_advisor_assignments saa
  join public.staff s on saa.staff_id = s.id
  where saa.advisor_code_number = advisor_code
    and saa.active = true;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_all_managers(advisor_code text)
 RETURNS TABLE(manager_code text, level_depth integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return query
  with recursive managers as (
    -- Base case: direct manager
    select
      m.manager_id as manager_code,
      1 as level_depth
    from public.manpower m
    where m.code_number = advisor_code
      and m.manager_id is not null

    union all

    -- Recursive case: manager's manager
    select
      m.manager_id as manager_code,
      mg.level_depth + 1
    from public.manpower m
    join managers mg on m.code_number = mg.manager_code
    where m.manager_id is not null
      and mg.level_depth < 10  -- Prevent infinite recursion
  )
  select * from managers;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_all_subordinates(manager_code text)
 RETURNS TABLE(subordinate_code text, level_depth integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return query
  with recursive subordinates as (
    -- Base case: direct reports
    select
      m.code_number as subordinate_code,
      1 as level_depth
    from public.manpower m
    where m.manager_id = manager_code

    union all

    -- Recursive case: reports of reports
    select
      m.code_number as subordinate_code,
      s.level_depth + 1
    from public.manpower m
    join subordinates s on m.manager_id = s.subordinate_code
    where s.level_depth < 10  -- Prevent infinite recursion
  )
  select * from subordinates;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_annual_production_data(p_start_year integer DEFAULT (EXTRACT(year FROM CURRENT_DATE) - (2)::numeric), p_end_year integer DEFAULT EXTRACT(year FROM CURRENT_DATE), p_period_type text DEFAULT 'calendar'::text, p_advisor_codes text[] DEFAULT NULL::text[], p_manager_ids text[] DEFAULT NULL::text[], p_unit_codes text[] DEFAULT NULL::text[])
 RETURNS TABLE(advisor_code text, advisor_name text, unit_code text, unit_name text, manager_id text, photo_url text, period_year integer, period_type text, period_start date, period_end date, total_settled_apps numeric, total_agency_credits numeric, total_net_sales_credits numeric, total_rn_commission_php numeric, total_submitted_apps numeric, months_with_activity integer, avg_monthly_settled_apps numeric, avg_monthly_agency_credits numeric, avg_monthly_net_sales_credits numeric, avg_monthly_rn_commission_php numeric, avg_monthly_submitted_apps numeric, peak_month_settled_apps numeric, peak_month_agency_credits numeric, peak_month_net_sales_credits numeric, peak_month_rn_commission_php numeric, peak_month_submitted_apps numeric, transaction_count integer, last_updated timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        aps.advisor_code,
        aps.advisor_name,
        aps.unit_code,
        aps.unit_name,
        aps.manager_id,
        aps.photo_url,
        aps.period_year,
        aps.period_type,
        aps.period_start,
        aps.period_end,
        aps.total_settled_apps,
        aps.total_agency_credits,
        aps.total_net_sales_credits,
        aps.total_rn_commission_php,
        aps.total_submitted_apps,
        aps.months_with_activity,
        aps.avg_monthly_settled_apps,
        aps.avg_monthly_agency_credits,
        aps.avg_monthly_net_sales_credits,
        aps.avg_monthly_rn_commission_php,
        aps.avg_monthly_submitted_apps,
        aps.peak_month_settled_apps,
        aps.peak_month_agency_credits,
        aps.peak_month_net_sales_credits,
        aps.peak_month_rn_commission_php,
        aps.peak_month_submitted_apps,
        aps.transaction_count,
        aps.last_updated
    FROM public.annual_production_summary aps
    WHERE
        -- Year filtering
        aps.period_year >= p_start_year
        AND aps.period_year <= p_end_year

        -- Period type filtering
        AND (
            p_period_type = 'both'
            OR aps.period_type = p_period_type
        )

        -- Advisor filtering (optional)
        AND (
            p_advisor_codes IS NULL
            OR aps.advisor_code = ANY(p_advisor_codes)
        )

        -- Manager filtering (optional)
        AND (
            p_manager_ids IS NULL
            OR aps.manager_id = ANY(p_manager_ids)
        )

        -- Unit filtering (optional)
        AND (
            p_unit_codes IS NULL
            OR aps.unit_code = ANY(p_unit_codes)
        )
    ORDER BY
        aps.advisor_code,
        aps.period_year,
        aps.period_type;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_annual_team_summary(p_year integer DEFAULT EXTRACT(year FROM CURRENT_DATE), p_period_type text DEFAULT 'calendar'::text, p_aggregation_level text DEFAULT 'manager'::text)
 RETURNS TABLE(grouping_key text, grouping_name text, advisor_count integer, active_advisor_count integer, total_settled_apps numeric, total_agency_credits numeric, total_net_sales_credits numeric, total_rn_commission_php numeric, total_submitted_apps numeric, avg_settled_apps_per_advisor numeric, avg_agency_credits_per_advisor numeric, avg_net_sales_credits_per_advisor numeric, avg_rn_commission_per_advisor numeric, avg_submitted_apps_per_advisor numeric, avg_months_active numeric, top_performer_code text, top_performer_name text, top_performer_net_sales numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF p_aggregation_level = 'manager' THEN
        RETURN QUERY
        WITH manager_performance AS (
            SELECT
                aps.manager_id,
                COALESCE(m.advisor_name, 'Unknown Manager') as manager_name,
                COUNT(*) as advisor_count,
                COUNT(CASE WHEN aps.total_net_sales_credits > 0 THEN 1 END) as active_advisor_count,
                SUM(aps.total_settled_apps) as total_settled_apps,
                SUM(aps.total_agency_credits) as total_agency_credits,
                SUM(aps.total_net_sales_credits) as total_net_sales_credits,
                SUM(aps.total_rn_commission_php) as total_rn_commission_php,
                SUM(aps.total_submitted_apps) as total_submitted_apps,
                AVG(aps.total_settled_apps) as avg_settled_apps_per_advisor,
                AVG(aps.total_agency_credits) as avg_agency_credits_per_advisor,
                AVG(aps.total_net_sales_credits) as avg_net_sales_credits_per_advisor,
                AVG(aps.total_rn_commission_php) as avg_rn_commission_per_advisor,
                AVG(aps.total_submitted_apps) as avg_submitted_apps_per_advisor,
                AVG(aps.months_with_activity::numeric) as avg_months_active
            FROM public.annual_production_summary aps
            LEFT JOIN public.manpower m ON aps.manager_id = m.code_number
            WHERE aps.period_year = p_year AND aps.period_type = p_period_type
            GROUP BY aps.manager_id, m.advisor_name
        ),
        top_performers AS (
            SELECT DISTINCT ON (aps.manager_id)
                aps.manager_id,
                aps.advisor_code,
                aps.advisor_name,
                aps.total_net_sales_credits
            FROM public.annual_production_summary aps
            WHERE aps.period_year = p_year AND aps.period_type = p_period_type
            ORDER BY aps.manager_id, aps.total_net_sales_credits DESC
        )
        SELECT
            mp.manager_id as grouping_key,
            mp.manager_name as grouping_name,
            mp.advisor_count::integer,
            mp.active_advisor_count::integer,
            mp.total_settled_apps,
            mp.total_agency_credits,
            mp.total_net_sales_credits,
            mp.total_rn_commission_php,
            mp.total_submitted_apps,
            mp.avg_settled_apps_per_advisor,
            mp.avg_agency_credits_per_advisor,
            mp.avg_net_sales_credits_per_advisor,
            mp.avg_rn_commission_per_advisor,
            mp.avg_submitted_apps_per_advisor,
            mp.avg_months_active,
            tp.advisor_code,
            tp.advisor_name,
            tp.total_net_sales_credits
        FROM manager_performance mp
        LEFT JOIN top_performers tp ON mp.manager_id = tp.manager_id
        ORDER BY mp.total_net_sales_credits DESC;

    ELSIF p_aggregation_level = 'unit' THEN
        RETURN QUERY
        WITH unit_performance AS (
            SELECT
                aps.unit_code,
                COALESCE(aps.unit_name, aps.unit_code) as unit_name,
                COUNT(*) as advisor_count,
                COUNT(CASE WHEN aps.total_net_sales_credits > 0 THEN 1 END) as active_advisor_count,
                SUM(aps.total_settled_apps) as total_settled_apps,
                SUM(aps.total_agency_credits) as total_agency_credits,
                SUM(aps.total_net_sales_credits) as total_net_sales_credits,
                SUM(aps.total_rn_commission_php) as total_rn_commission_php,
                SUM(aps.total_submitted_apps) as total_submitted_apps,
                AVG(aps.total_settled_apps) as avg_settled_apps_per_advisor,
                AVG(aps.total_agency_credits) as avg_agency_credits_per_advisor,
                AVG(aps.total_net_sales_credits) as avg_net_sales_credits_per_advisor,
                AVG(aps.total_rn_commission_php) as avg_rn_commission_per_advisor,
                AVG(aps.total_submitted_apps) as avg_submitted_apps_per_advisor,
                AVG(aps.months_with_activity::numeric) as avg_months_active
            FROM public.annual_production_summary aps
            WHERE aps.period_year = p_year AND aps.period_type = p_period_type
            GROUP BY aps.unit_code, aps.unit_name
        ),
        top_performers AS (
            SELECT DISTINCT ON (aps.unit_code)
                aps.unit_code,
                aps.advisor_code,
                aps.advisor_name,
                aps.total_net_sales_credits
            FROM public.annual_production_summary aps
            WHERE aps.period_year = p_year AND aps.period_type = p_period_type
            ORDER BY aps.unit_code, aps.total_net_sales_credits DESC
        )
        SELECT
            up.unit_code as grouping_key,
            up.unit_name as grouping_name,
            up.advisor_count::integer,
            up.active_advisor_count::integer,
            up.total_settled_apps,
            up.total_agency_credits,
            up.total_net_sales_credits,
            up.total_rn_commission_php,
            up.total_submitted_apps,
            up.avg_settled_apps_per_advisor,
            up.avg_agency_credits_per_advisor,
            up.avg_net_sales_credits_per_advisor,
            up.avg_rn_commission_per_advisor,
            up.avg_submitted_apps_per_advisor,
            up.avg_months_active,
            tp.advisor_code,
            tp.advisor_name,
            tp.total_net_sales_credits
        FROM unit_performance up
        LEFT JOIN top_performers tp ON up.unit_code = tp.unit_code
        ORDER BY up.total_net_sales_credits DESC;
    ELSE
        -- Overall summary
        RETURN QUERY
        WITH overall_performance AS (
            SELECT
                COUNT(*) as advisor_count,
                COUNT(CASE WHEN aps.total_net_sales_credits > 0 THEN 1 END) as active_advisor_count,
                SUM(aps.total_settled_apps) as total_settled_apps,
                SUM(aps.total_agency_credits) as total_agency_credits,
                SUM(aps.total_net_sales_credits) as total_net_sales_credits,
                SUM(aps.total_rn_commission_php) as total_rn_commission_php,
                SUM(aps.total_submitted_apps) as total_submitted_apps,
                AVG(aps.total_settled_apps) as avg_settled_apps_per_advisor,
                AVG(aps.total_agency_credits) as avg_agency_credits_per_advisor,
                AVG(aps.total_net_sales_credits) as avg_net_sales_credits_per_advisor,
                AVG(aps.total_rn_commission_php) as avg_rn_commission_per_advisor,
                AVG(aps.total_submitted_apps) as avg_submitted_apps_per_advisor,
                AVG(aps.months_with_activity::numeric) as avg_months_active
            FROM public.annual_production_summary aps
            WHERE aps.period_year = p_year AND aps.period_type = p_period_type
        ),
        top_performer AS (
            SELECT
                aps.advisor_code,
                aps.advisor_name,
                aps.total_net_sales_credits
            FROM public.annual_production_summary aps
            WHERE aps.period_year = p_year AND aps.period_type = p_period_type
            ORDER BY aps.total_net_sales_credits DESC
            LIMIT 1
        )
        SELECT
            'overall'::text as grouping_key,
            'Organization Total'::text as grouping_name,
            op.advisor_count::integer,
            op.active_advisor_count::integer,
            op.total_settled_apps,
            op.total_agency_credits,
            op.total_net_sales_credits,
            op.total_rn_commission_php,
            op.total_submitted_apps,
            op.avg_settled_apps_per_advisor,
            op.avg_agency_credits_per_advisor,
            op.avg_net_sales_credits_per_advisor,
            op.avg_rn_commission_per_advisor,
            op.avg_submitted_apps_per_advisor,
            op.avg_months_active,
            tp.advisor_code,
            tp.advisor_name,
            tp.total_net_sales_credits
        FROM overall_performance op
        CROSS JOIN top_performer tp;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_avatar_url(user_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  avatar_path text;
begin
  select photo_url into avatar_path
  from public.profiles
  where profiles.user_id = get_avatar_url.user_id;

  return avatar_path;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_calendar_period(p_date date)
 RETURNS TABLE(period_year integer, period_month integer, period_start date, period_end date)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY SELECT
        EXTRACT(year FROM p_date)::integer,
        EXTRACT(month FROM p_date)::integer,
        date_trunc('month', p_date)::date,
        (date_trunc('month', p_date) + INTERVAL '1 month' - INTERVAL '1 day')::date;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_calendar_year_period(p_year integer)
 RETURNS TABLE(period_start date, period_end date)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY SELECT
        make_date(p_year, 1, 1) as period_start,
        make_date(p_year, 12, 31) as period_end;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_duplicate_statistics(p_table_names text[])
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  table_name text;
  duplicate_count integer := 0;
  total_records integer := 0;
  table_results jsonb := '{}';
BEGIN
  FOREACH table_name IN ARRAY p_table_names
  LOOP
    BEGIN
      CASE table_name
        WHEN 'submitted_apps_details' THEN
          WITH duplicate_groups AS (
            SELECT COUNT(*) as duplicate_count
            FROM submitted_apps_details
            WHERE advisor_code IS NOT NULL
            GROUP BY advisor_code, advisor_name, process_date, insured_name, policy_number, submitted_apps
            HAVING COUNT(*) > 1
          )
          SELECT
            COALESCE(SUM(duplicate_count - 1), 0),
            (SELECT COUNT(*) FROM submitted_apps_details)
          INTO duplicate_count, total_records;

        WHEN 'settled_apps_details' THEN
          WITH duplicate_groups AS (
            SELECT COUNT(*) as duplicate_count
            FROM settled_apps_details
            WHERE advisor_code IS NOT NULL
            GROUP BY advisor_code, advisor_name, process_date, insured_name, policy_number, settled_apps, agency_credits, net_sales_credits
            HAVING COUNT(*) > 1
          )
          SELECT
            COALESCE(SUM(duplicate_count - 1), 0),
            (SELECT COUNT(*) FROM settled_apps_details)
          INTO duplicate_count, total_records;

        WHEN 'fy_commission_details' THEN
          WITH duplicate_groups AS (
            SELECT COUNT(*) as duplicate_count
            FROM fy_commission_details
            WHERE code IS NOT NULL
            GROUP BY code, process_date, insured_name, policy_number, transaction_type, fy_premium_php, due_date, rate, fy_commission_php
            HAVING COUNT(*) > 1
          )
          SELECT
            COALESCE(SUM(duplicate_count - 1), 0),
            (SELECT COUNT(*) FROM fy_commission_details)
          INTO duplicate_count, total_records;

        WHEN 'rn_commission_details' THEN
          WITH duplicate_groups AS (
            SELECT COUNT(*) as duplicate_count
            FROM rn_commission_details
            WHERE code IS NOT NULL
            GROUP BY code, process_date, insured_name, policy_number, transaction_type, rn_premium_php, due_date, rate, year, rn_commission_php
            HAVING COUNT(*) > 1
          )
          SELECT
            COALESCE(SUM(duplicate_count - 1), 0),
            (SELECT COUNT(*) FROM rn_commission_details)
          INTO duplicate_count, total_records;

        ELSE
          duplicate_count := 0;
          total_records := 0;
      END CASE;

      table_results := table_results || jsonb_build_object(
        table_name, jsonb_build_object(
          'total_records', total_records,
          'duplicate_records', duplicate_count,
          'unique_records', total_records - duplicate_count
        )
      );

    EXCEPTION
      WHEN OTHERS THEN
        table_results := table_results || jsonb_build_object(
          table_name, jsonb_build_object(
            'total_records', 0,
            'duplicate_records', 0,
            'unique_records', 0,
            'error', SQLERRM
          )
        );
    END;
  END LOOP;

  RETURN jsonb_build_object(
    'success', true,
    'table_statistics', table_results
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'table_statistics', '{}',
      'error', SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_monthly_production_data(p_start_year integer DEFAULT (EXTRACT(year FROM CURRENT_DATE) - (2)::numeric), p_end_year integer DEFAULT EXTRACT(year FROM CURRENT_DATE), p_period_type text DEFAULT 'calendar'::text, p_advisor_codes text[] DEFAULT NULL::text[], p_manager_ids text[] DEFAULT NULL::text[], p_unit_codes text[] DEFAULT NULL::text[], p_start_month integer DEFAULT NULL::integer, p_end_month integer DEFAULT NULL::integer)
 RETURNS TABLE(advisor_code text, advisor_name text, unit_code text, unit_name text, manager_id text, photo_url text, period_year integer, period_month integer, period_type text, period_start date, period_end date, total_settled_apps numeric, total_agency_credits numeric, total_net_sales_credits numeric, total_rn_commission_php numeric, total_submitted_apps numeric, transaction_count integer, last_updated timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        mps.advisor_code,
        mps.advisor_name,
        mps.unit_code,
        mps.unit_name,
        mps.manager_id,
        mps.photo_url,
        mps.period_year,
        mps.period_month,
        mps.period_type,
        mps.period_start,
        mps.period_end,
        mps.total_settled_apps,
        mps.total_agency_credits,
        mps.total_net_sales_credits,
        mps.total_rn_commission_php,
        mps.total_submitted_apps,
        mps.transaction_count,
        mps.last_updated
    FROM public.monthly_production_summary mps
    WHERE
        -- Year filtering
        mps.period_year >= p_start_year
        AND mps.period_year <= p_end_year

        -- Period type filtering
        AND (
            p_period_type = 'both'
            OR mps.period_type = p_period_type
        )

        -- Month filtering (optional)
        AND (
            p_start_month IS NULL
            OR mps.period_month >= p_start_month
        )
        AND (
            p_end_month IS NULL
            OR mps.period_month <= p_end_month
        )

        -- Advisor filtering (optional)
        AND (
            p_advisor_codes IS NULL
            OR mps.advisor_code = ANY(p_advisor_codes)
        )

        -- Manager filtering (optional)
        AND (
            p_manager_ids IS NULL
            OR mps.manager_id = ANY(p_manager_ids)
        )

        -- Unit filtering (optional)
        AND (
            p_unit_codes IS NULL
            OR mps.unit_code = ANY(p_unit_codes)
        )
    ORDER BY
        mps.advisor_code,
        mps.period_year,
        mps.period_month,
        mps.period_type;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_staff_assigned_advisors(staff_uuid uuid)
 RETURNS TABLE(advisor_code text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return query
  select saa.advisor_code_number
  from public.staff_advisor_assignments saa
  join public.staff s on saa.staff_id = s.id
  where s.profile_user_id = staff_uuid
    and saa.active = true;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_systems_period(p_date date)
 RETURNS TABLE(period_year integer, period_month integer, period_start date, period_end date)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        scp.period_year,
        scp.period_month,
        scp.start_date,
        scp.end_date
    FROM public.cal_systems_closing_periods scp
    WHERE p_date >= scp.start_date AND p_date <= scp.end_date
    LIMIT 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_systems_year_period(p_year integer)
 RETURNS TABLE(period_start date, period_end date)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        MIN(scp.start_date) as period_start,
        MAX(scp.end_date) as period_end
    FROM public.cal_systems_closing_periods scp
    WHERE scp.period_year = p_year;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_team_members(head_manager_code text)
 RETURNS TABLE(member_code text, member_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return query
  select m.code_number, m.advisor_name
  from public.manpower m
  join public.teams t on m.team_id = t.id
  where t.head_manpower_code = head_manager_code;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_team_production_summary(p_year integer DEFAULT EXTRACT(year FROM CURRENT_DATE), p_period_type text DEFAULT 'calendar'::text, p_aggregation_level text DEFAULT 'manager'::text)
 RETURNS TABLE(grouping_key text, grouping_name text, advisor_count integer, total_settled_apps numeric, total_agency_credits numeric, total_net_sales_credits numeric, total_rn_commission_php numeric, total_submitted_apps numeric, avg_settled_apps_per_advisor numeric, avg_agency_credits_per_advisor numeric, avg_net_sales_credits_per_advisor numeric, avg_rn_commission_per_advisor numeric, avg_submitted_apps_per_advisor numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF p_aggregation_level = 'manager' THEN
        RETURN QUERY
        SELECT
            mps.manager_id as grouping_key,
            COALESCE(m.advisor_name, 'Unknown Manager') as grouping_name,
            COUNT(DISTINCT mps.advisor_code)::integer as advisor_count,
            SUM(mps.total_settled_apps) as total_settled_apps,
            SUM(mps.total_agency_credits) as total_agency_credits,
            SUM(mps.total_net_sales_credits) as total_net_sales_credits,
            SUM(mps.total_rn_commission_php) as total_rn_commission_php,
            SUM(mps.total_submitted_apps) as total_submitted_apps,
            AVG(mps.total_settled_apps) as avg_settled_apps_per_advisor,
            AVG(mps.total_agency_credits) as avg_agency_credits_per_advisor,
            AVG(mps.total_net_sales_credits) as avg_net_sales_credits_per_advisor,
            AVG(mps.total_rn_commission_php) as avg_rn_commission_per_advisor,
            AVG(mps.total_submitted_apps) as avg_submitted_apps_per_advisor
        FROM public.monthly_production_summary mps
        LEFT JOIN public.manpower m ON mps.manager_id = m.code_number
        WHERE
            mps.period_year = p_year
            AND mps.period_type = p_period_type
        GROUP BY mps.manager_id, m.advisor_name
        ORDER BY SUM(mps.total_net_sales_credits) DESC;

    ELSIF p_aggregation_level = 'unit' THEN
        RETURN QUERY
        SELECT
            mps.unit_code as grouping_key,
            COALESCE(mps.unit_name, mps.unit_code) as grouping_name,
            COUNT(DISTINCT mps.advisor_code)::integer as advisor_count,
            SUM(mps.total_settled_apps) as total_settled_apps,
            SUM(mps.total_agency_credits) as total_agency_credits,
            SUM(mps.total_net_sales_credits) as total_net_sales_credits,
            SUM(mps.total_rn_commission_php) as total_rn_commission_php,
            SUM(mps.total_submitted_apps) as total_submitted_apps,
            AVG(mps.total_settled_apps) as avg_settled_apps_per_advisor,
            AVG(mps.total_agency_credits) as avg_agency_credits_per_advisor,
            AVG(mps.total_net_sales_credits) as avg_net_sales_credits_per_advisor,
            AVG(mps.total_rn_commission_php) as avg_rn_commission_per_advisor,
            AVG(mps.total_submitted_apps) as avg_submitted_apps_per_advisor
        FROM public.monthly_production_summary mps
        WHERE
            mps.period_year = p_year
            AND mps.period_type = p_period_type
        GROUP BY mps.unit_code, mps.unit_name
        ORDER BY SUM(mps.total_net_sales_credits) DESC;
    ELSE
        -- Overall summary
        RETURN QUERY
        SELECT
            'overall'::text as grouping_key,
            'Organization Total'::text as grouping_name,
            COUNT(DISTINCT mps.advisor_code)::integer as advisor_count,
            SUM(mps.total_settled_apps) as total_settled_apps,
            SUM(mps.total_agency_credits) as total_agency_credits,
            SUM(mps.total_net_sales_credits) as total_net_sales_credits,
            SUM(mps.total_rn_commission_php) as total_rn_commission_php,
            SUM(mps.total_submitted_apps) as total_submitted_apps,
            AVG(mps.total_settled_apps) as avg_settled_apps_per_advisor,
            AVG(mps.total_agency_credits) as avg_agency_credits_per_advisor,
            AVG(mps.total_net_sales_credits) as avg_net_sales_credits_per_advisor,
            AVG(mps.total_rn_commission_php) as avg_rn_commission_per_advisor,
            AVG(mps.total_submitted_apps) as avg_submitted_apps_per_advisor
        FROM public.monthly_production_summary mps
        WHERE
            mps.period_year = p_year
            AND mps.period_type = p_period_type;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_app_role(user_uuid uuid)
 RETURNS app_role_type
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return (
    select app_role
    from public.profiles
    where user_id = user_uuid
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_manpower_code(user_uuid uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return (
    select code_number
    from public.manpower
    where profile_user_id = user_uuid
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_staff_id(user_uuid uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return (
    select id
    from public.staff
    where profile_user_id = user_uuid
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.profiles (user_id, email, created_at, updated_at)
  values (new.id, new.email, now(), now());
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.is_subordinate_of(subordinate_code text, manager_code text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return exists(
    select 1
    from public.get_all_subordinates(manager_code) as subordinates
    where subordinates.subordinate_code = $1
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.is_user_active(user_uuid uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  return exists(
    select 1
    from public.profiles
    where user_id = user_uuid
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.populate_annual_production_summary(p_start_year integer DEFAULT (EXTRACT(year FROM CURRENT_DATE) - (2)::numeric), p_end_year integer DEFAULT EXTRACT(year FROM CURRENT_DATE))
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    advisor_rec RECORD;
    year_rec RECORD;
    processed_count integer := 0;
BEGIN
    -- Clear existing annual data for the year range
    DELETE FROM public.annual_production_summary
    WHERE period_year >= p_start_year AND period_year <= p_end_year;

    -- Loop through all advisors
    FOR advisor_rec IN
        SELECT DISTINCT code_number
        FROM public.manpower
        WHERE code_number IS NOT NULL
    LOOP
        -- Loop through each year in the range
        FOR year_rec IN
            SELECT generate_series(p_start_year, p_end_year) as year_value
        LOOP
            -- Calculate calendar annual summary
            PERFORM recalculate_annual_summary(
                advisor_rec.code_number,
                year_rec.year_value,
                'calendar'
            );
            processed_count := processed_count + 1;

            -- Calculate systems annual summary (if systems periods exist for this year)
            IF EXISTS (
                SELECT 1 FROM public.cal_systems_closing_periods
                WHERE period_year = year_rec.year_value
            ) THEN
                PERFORM recalculate_annual_summary(
                    advisor_rec.code_number,
                    year_rec.year_value,
                    'systems'
                );
                processed_count := processed_count + 1;
            END IF;
        END LOOP;
    END LOOP;

    RETURN 'Populated annual production summary for ' || p_start_year || '-' || p_end_year ||
           '. Processed ' || processed_count || ' advisor-year combinations.';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.populate_monthly_production_summary(p_start_year integer DEFAULT (EXTRACT(year FROM CURRENT_DATE) - (2)::numeric), p_end_year integer DEFAULT EXTRACT(year FROM CURRENT_DATE))
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    advisor_rec RECORD;
    cal_period RECORD;
    sys_period RECORD;
    processed_count integer := 0;
BEGIN
    -- Clear existing data for the year range
    DELETE FROM public.monthly_production_summary
    WHERE period_year >= p_start_year AND period_year <= p_end_year;

    -- Loop through all advisors
    FOR advisor_rec IN
        SELECT code_number FROM public.manpower
        WHERE code_number IS NOT NULL
    LOOP
        -- Generate calendar periods for each advisor
        FOR cal_period IN
            SELECT
                EXTRACT(year FROM month_date)::integer as period_year,
                EXTRACT(month FROM month_date)::integer as period_month,
                month_date::date as period_start,
                (date_trunc('month', month_date) + INTERVAL '1 month' - INTERVAL '1 day')::date as period_end
            FROM generate_series(
                make_date(p_start_year, 1, 1)::timestamp,
                make_date(p_end_year, 12, 31)::timestamp,
                '1 month'::interval
            ) month_date
        LOOP
            PERFORM recalculate_monthly_summary(
                advisor_rec.code_number,
                cal_period.period_year,
                cal_period.period_month,
                'calendar',
                cal_period.period_start,
                cal_period.period_end
            );
            processed_count := processed_count + 1;
        END LOOP;

        -- Generate systems periods for each advisor (if any exist)
        FOR sys_period IN
            SELECT
                period_year,
                period_month,
                start_date,
                end_date
            FROM public.cal_systems_closing_periods
            WHERE period_year >= p_start_year AND period_year <= p_end_year
        LOOP
            PERFORM recalculate_monthly_summary(
                advisor_rec.code_number,
                sys_period.period_year,
                sys_period.period_month,
                'systems',
                sys_period.start_date,
                sys_period.end_date
            );
            processed_count := processed_count + 1;
        END LOOP;
    END LOOP;

    RETURN 'Populated monthly production summary for ' || p_start_year || '-' || p_end_year ||
           '. Processed ' || processed_count || ' advisor-period combinations.';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.recalculate_annual_summary(p_advisor_code text, p_period_year integer, p_period_type text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    advisor_info RECORD;
    period_info RECORD;
    summary_data RECORD;
BEGIN
    -- Get advisor information with team details
    SELECT
        m.advisor_name,
        m.unit_code,
        m.manager_id,
        m.photo_url,
        COALESCE(t.unit_name, m.unit_code) as unit_name
    INTO advisor_info
    FROM public.manpower m
    LEFT JOIN public.teams t ON m.team_id = t.id
    WHERE m.code_number = p_advisor_code;

    -- If advisor doesn't exist, exit
    IF NOT FOUND THEN
        RETURN;
    END IF;

    -- Get period boundaries based on type
    IF p_period_type = 'calendar' THEN
        SELECT * INTO period_info FROM get_calendar_year_period(p_period_year);
    ELSE
        SELECT * INTO period_info FROM get_systems_year_period(p_period_year);
    END IF;

    -- If no period found, exit
    IF period_info.period_start IS NULL OR period_info.period_end IS NULL THEN
        RETURN;
    END IF;

    -- Aggregate annual data from monthly summaries (preferred method for performance)
    WITH annual_totals AS (
        SELECT
            COALESCE(SUM(total_settled_apps), 0) as total_settled_apps,
            COALESCE(SUM(total_agency_credits), 0) as total_agency_credits,
            COALESCE(SUM(total_net_sales_credits), 0) as total_net_sales_credits,
            COALESCE(SUM(total_rn_commission_php), 0) as total_rn_commission_php,
            COALESCE(SUM(total_submitted_apps), 0) as total_submitted_apps,
            COALESCE(SUM(transaction_count), 0) as transaction_count
        FROM public.monthly_production_summary
        WHERE advisor_code = p_advisor_code
            AND period_year = p_period_year
            AND period_type = p_period_type
    ),
    monthly_activity AS (
        SELECT
            COUNT(*) as months_with_activity,
            -- Average calculations
            COALESCE(AVG(total_settled_apps), 0) as avg_monthly_settled_apps,
            COALESCE(AVG(total_agency_credits), 0) as avg_monthly_agency_credits,
            COALESCE(AVG(total_net_sales_credits), 0) as avg_monthly_net_sales_credits,
            COALESCE(AVG(total_rn_commission_php), 0) as avg_monthly_rn_commission_php,
            COALESCE(AVG(total_submitted_apps), 0) as avg_monthly_submitted_apps,
            -- Peak calculations
            COALESCE(MAX(total_settled_apps), 0) as peak_month_settled_apps,
            COALESCE(MAX(total_agency_credits), 0) as peak_month_agency_credits,
            COALESCE(MAX(total_net_sales_credits), 0) as peak_month_net_sales_credits,
            COALESCE(MAX(total_rn_commission_php), 0) as peak_month_rn_commission_php,
            COALESCE(MAX(total_submitted_apps), 0) as peak_month_submitted_apps
        FROM public.monthly_production_summary
        WHERE advisor_code = p_advisor_code
            AND period_year = p_period_year
            AND period_type = p_period_type
            AND (total_settled_apps > 0 OR total_agency_credits > 0 OR total_net_sales_credits > 0
                 OR total_rn_commission_php > 0 OR total_submitted_apps > 0)
    )
    SELECT
        at.total_settled_apps,
        at.total_agency_credits,
        at.total_net_sales_credits,
        at.total_rn_commission_php,
        at.total_submitted_apps,
        at.transaction_count,
        COALESCE(ma.months_with_activity, 0) as months_with_activity,
        ma.avg_monthly_settled_apps,
        ma.avg_monthly_agency_credits,
        ma.avg_monthly_net_sales_credits,
        ma.avg_monthly_rn_commission_php,
        ma.avg_monthly_submitted_apps,
        ma.peak_month_settled_apps,
        ma.peak_month_agency_credits,
        ma.peak_month_net_sales_credits,
        ma.peak_month_rn_commission_php,
        ma.peak_month_submitted_apps
    INTO summary_data
    FROM annual_totals at
    FULL OUTER JOIN monthly_activity ma ON true;

    -- Upsert the annual summary record
    INSERT INTO public.annual_production_summary (
        advisor_code,
        period_year,
        period_type,
        period_start,
        period_end,
        advisor_name,
        unit_code,
        unit_name,
        manager_id,
        photo_url,
        total_settled_apps,
        total_agency_credits,
        total_net_sales_credits,
        total_rn_commission_php,
        total_submitted_apps,
        months_with_activity,
        avg_monthly_settled_apps,
        avg_monthly_agency_credits,
        avg_monthly_net_sales_credits,
        avg_monthly_rn_commission_php,
        avg_monthly_submitted_apps,
        peak_month_settled_apps,
        peak_month_agency_credits,
        peak_month_net_sales_credits,
        peak_month_rn_commission_php,
        peak_month_submitted_apps,
        transaction_count,
        last_updated
    )
    VALUES (
        p_advisor_code,
        p_period_year,
        p_period_type,
        period_info.period_start,
        period_info.period_end,
        advisor_info.advisor_name,
        advisor_info.unit_code,
        advisor_info.unit_name,
        advisor_info.manager_id,
        advisor_info.photo_url,
        summary_data.total_settled_apps,
        summary_data.total_agency_credits,
        summary_data.total_net_sales_credits,
        summary_data.total_rn_commission_php,
        summary_data.total_submitted_apps,
        summary_data.months_with_activity,
        summary_data.avg_monthly_settled_apps,
        summary_data.avg_monthly_agency_credits,
        summary_data.avg_monthly_net_sales_credits,
        summary_data.avg_monthly_rn_commission_php,
        summary_data.avg_monthly_submitted_apps,
        summary_data.peak_month_settled_apps,
        summary_data.peak_month_agency_credits,
        summary_data.peak_month_net_sales_credits,
        summary_data.peak_month_rn_commission_php,
        summary_data.peak_month_submitted_apps,
        summary_data.transaction_count,
        now()
    )
    ON CONFLICT (advisor_code, period_year, period_type)
    DO UPDATE SET
        period_start = EXCLUDED.period_start,
        period_end = EXCLUDED.period_end,
        advisor_name = EXCLUDED.advisor_name,
        unit_code = EXCLUDED.unit_code,
        unit_name = EXCLUDED.unit_name,
        manager_id = EXCLUDED.manager_id,
        photo_url = EXCLUDED.photo_url,
        total_settled_apps = EXCLUDED.total_settled_apps,
        total_agency_credits = EXCLUDED.total_agency_credits,
        total_net_sales_credits = EXCLUDED.total_net_sales_credits,
        total_rn_commission_php = EXCLUDED.total_rn_commission_php,
        total_submitted_apps = EXCLUDED.total_submitted_apps,
        months_with_activity = EXCLUDED.months_with_activity,
        avg_monthly_settled_apps = EXCLUDED.avg_monthly_settled_apps,
        avg_monthly_agency_credits = EXCLUDED.avg_monthly_agency_credits,
        avg_monthly_net_sales_credits = EXCLUDED.avg_monthly_net_sales_credits,
        avg_monthly_rn_commission_php = EXCLUDED.avg_monthly_rn_commission_php,
        avg_monthly_submitted_apps = EXCLUDED.avg_monthly_submitted_apps,
        peak_month_settled_apps = EXCLUDED.peak_month_settled_apps,
        peak_month_agency_credits = EXCLUDED.peak_month_agency_credits,
        peak_month_net_sales_credits = EXCLUDED.peak_month_net_sales_credits,
        peak_month_rn_commission_php = EXCLUDED.peak_month_rn_commission_php,
        peak_month_submitted_apps = EXCLUDED.peak_month_submitted_apps,
        transaction_count = EXCLUDED.transaction_count,
        last_updated = EXCLUDED.last_updated;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.recalculate_monthly_summary(p_advisor_code text, p_period_year integer, p_period_month integer, p_period_type text, p_period_start date, p_period_end date)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    advisor_info RECORD;
    summary_data RECORD;
BEGIN
    -- Get advisor information with team details
    SELECT
        m.advisor_name,
        m.unit_code,
        m.manager_id,
        m.photo_url,
        COALESCE(t.unit_name, m.unit_code) as unit_name
    INTO advisor_info
    FROM public.manpower m
    LEFT JOIN public.teams t ON m.team_id = t.id
    WHERE m.code_number = p_advisor_code;

    -- If advisor doesn't exist, exit
    IF NOT FOUND THEN
        RETURN;
    END IF;

    -- Aggregate all production data for the period
    WITH settled_data AS (
        SELECT
            COALESCE(SUM(settled_apps), 0) as total_settled_apps,
            COALESCE(SUM(agency_credits), 0) as total_agency_credits,
            COALESCE(SUM(net_sales_credits), 0) as total_net_sales_credits,
            COUNT(*) as settled_count
        FROM public.settled_apps_details
        WHERE advisor_code = p_advisor_code
            AND process_date >= p_period_start
            AND process_date <= p_period_end
    ),
    commission_data AS (
        SELECT
            COALESCE(SUM(rn_commission_php), 0) as total_rn_commission_php,
            COUNT(*) as commission_count
        FROM public.rn_commission_details
        WHERE code = p_advisor_code
            AND process_date >= p_period_start
            AND process_date <= p_period_end
    ),
    submitted_data AS (
        SELECT
            COALESCE(SUM(submitted_apps), 0) as total_submitted_apps,
            COUNT(*) as submitted_count
        FROM public.submitted_apps_details
        WHERE advisor_code = p_advisor_code
            AND process_date >= p_period_start
            AND process_date <= p_period_end
    )
    SELECT
        sd.total_settled_apps,
        sd.total_agency_credits,
        sd.total_net_sales_credits,
        cd.total_rn_commission_php,
        sub.total_submitted_apps,
        (sd.settled_count + cd.commission_count + sub.submitted_count) as total_transactions
    INTO summary_data
    FROM settled_data sd, commission_data cd, submitted_data sub;

    -- Upsert the summary record
    INSERT INTO public.monthly_production_summary (
        advisor_code,
        period_year,
        period_month,
        period_type,
        period_start,
        period_end,
        advisor_name,
        unit_code,
        unit_name,
        manager_id,
        photo_url,
        total_settled_apps,
        total_agency_credits,
        total_net_sales_credits,
        total_rn_commission_php,
        total_submitted_apps,
        transaction_count,
        last_updated
    )
    VALUES (
        p_advisor_code,
        p_period_year,
        p_period_month,
        p_period_type,
        p_period_start,
        p_period_end,
        advisor_info.advisor_name,
        advisor_info.unit_code,
        advisor_info.unit_name,
        advisor_info.manager_id,
        advisor_info.photo_url,
        summary_data.total_settled_apps,
        summary_data.total_agency_credits,
        summary_data.total_net_sales_credits,
        summary_data.total_rn_commission_php,
        summary_data.total_submitted_apps,
        summary_data.total_transactions,
        now()
    )
    ON CONFLICT (advisor_code, period_year, period_month, period_type)
    DO UPDATE SET
        period_start = EXCLUDED.period_start,
        period_end = EXCLUDED.period_end,
        advisor_name = EXCLUDED.advisor_name,
        unit_code = EXCLUDED.unit_code,
        unit_name = EXCLUDED.unit_name,
        manager_id = EXCLUDED.manager_id,
        photo_url = EXCLUDED.photo_url,
        total_settled_apps = EXCLUDED.total_settled_apps,
        total_agency_credits = EXCLUDED.total_agency_credits,
        total_net_sales_credits = EXCLUDED.total_net_sales_credits,
        total_rn_commission_php = EXCLUDED.total_rn_commission_php,
        total_submitted_apps = EXCLUDED.total_submitted_apps,
        transaction_count = EXCLUDED.transaction_count,
        last_updated = EXCLUDED.last_updated;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.remove_duplicates_from_tables(p_table_names text[])
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  table_name text;
  duplicates_removed integer := 0;
  total_duplicates_removed integer := 0;
  errors text[] := ARRAY[]::text[];
  table_results jsonb := '{}';
BEGIN
  FOREACH table_name IN ARRAY p_table_names
  LOOP
    duplicates_removed := 0;

    BEGIN
      CASE table_name
        WHEN 'submitted_apps_details' THEN
          WITH duplicate_groups AS (
            SELECT
              advisor_code, advisor_name, process_date, insured_name, policy_number, submitted_apps,
              COUNT(*) as cnt,
              array_agg(id ORDER BY created_at DESC) as ids
            FROM submitted_apps_details
            WHERE advisor_code IS NOT NULL
            GROUP BY advisor_code, advisor_name, process_date, insured_name, policy_number, submitted_apps
            HAVING COUNT(*) > 1
          )
          DELETE FROM submitted_apps_details
          WHERE id IN (
            SELECT unnest(ids[2:]) FROM duplicate_groups
          );

          GET DIAGNOSTICS duplicates_removed = ROW_COUNT;

        WHEN 'settled_apps_details' THEN
          WITH duplicate_groups AS (
            SELECT
              advisor_code, advisor_name, process_date, insured_name, policy_number, settled_apps, agency_credits, net_sales_credits,
              COUNT(*) as cnt,
              array_agg(id ORDER BY created_at DESC) as ids
            FROM settled_apps_details
            WHERE advisor_code IS NOT NULL
            GROUP BY advisor_code, advisor_name, process_date, insured_name, policy_number, settled_apps, agency_credits, net_sales_credits
            HAVING COUNT(*) > 1
          )
          DELETE FROM settled_apps_details
          WHERE id IN (
            SELECT unnest(ids[2:]) FROM duplicate_groups
          );

          GET DIAGNOSTICS duplicates_removed = ROW_COUNT;

        WHEN 'fy_commission_details' THEN
          WITH duplicate_groups AS (
            SELECT
              code, process_date, insured_name, policy_number, transaction_type, fy_premium_php, due_date, rate, fy_commission_php,
              COUNT(*) as cnt,
              array_agg(id ORDER BY created_at DESC) as ids
            FROM fy_commission_details
            WHERE code IS NOT NULL
            GROUP BY code, process_date, insured_name, policy_number, transaction_type, fy_premium_php, due_date, rate, fy_commission_php
            HAVING COUNT(*) > 1
          )
          DELETE FROM fy_commission_details
          WHERE id IN (
            SELECT unnest(ids[2:]) FROM duplicate_groups
          );

          GET DIAGNOSTICS duplicates_removed = ROW_COUNT;

        WHEN 'rn_commission_details' THEN
          WITH duplicate_groups AS (
            SELECT
              code, process_date, insured_name, policy_number, transaction_type, rn_premium_php, due_date, rate, year, rn_commission_php,
              COUNT(*) as cnt,
              array_agg(id ORDER BY created_at DESC) as ids
            FROM rn_commission_details
            WHERE code IS NOT NULL
            GROUP BY code, process_date, insured_name, policy_number, transaction_type, rn_premium_php, due_date, rate, year, rn_commission_php
            HAVING COUNT(*) > 1
          )
          DELETE FROM rn_commission_details
          WHERE id IN (
            SELECT unnest(ids[2:]) FROM duplicate_groups
          );

          GET DIAGNOSTICS duplicates_removed = ROW_COUNT;

        ELSE
          errors := errors || ('Invalid table name: ' || table_name);
          CONTINUE;
      END CASE;

      table_results := table_results || jsonb_build_object(
        table_name, jsonb_build_object(
          'duplicates_removed', duplicates_removed,
          'success', true
        )
      );

      total_duplicates_removed := total_duplicates_removed + duplicates_removed;

    EXCEPTION
      WHEN OTHERS THEN
        errors := errors || (table_name || ' error: ' || SQLERRM);
        table_results := table_results || jsonb_build_object(
          table_name, jsonb_build_object(
            'duplicates_removed', 0,
            'success', false,
            'error', SQLERRM
          )
        );
    END;
  END LOOP;

  RETURN jsonb_build_object(
    'success', array_length(errors, 1) IS NULL,
    'total_duplicates_removed', total_duplicates_removed,
    'tables_processed', array_length(p_table_names, 1),
    'table_results', table_results,
    'errors', COALESCE(errors, ARRAY[]::text[])
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'total_duplicates_removed', 0,
      'tables_processed', 0,
      'table_results', '{}',
      'errors', ARRAY['Function error: ' || SQLERRM]
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_manpower_unit_code()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only sync if team_id has changed or this is an INSERT with team_id
  IF (TG_OP = 'INSERT' AND NEW.team_id IS NOT NULL) OR
     (TG_OP = 'UPDATE' AND (OLD.team_id IS DISTINCT FROM NEW.team_id) AND NEW.team_id IS NOT NULL) THEN

    -- Fetch unit_code from teams table
    SELECT unit_code INTO NEW.unit_code
    FROM public.teams
    WHERE id = NEW.team_id;

    -- Update the updated_at timestamp (this will be handled by existing trigger)
  END IF;

  -- If team_id is set to NULL, clear unit_code
  IF TG_OP = 'UPDATE' AND NEW.team_id IS NULL AND OLD.team_id IS NOT NULL THEN
    NEW.unit_code = NULL;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_teams_unit_code_to_manpower()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only proceed if unit_code has actually changed
  IF TG_OP = 'UPDATE' AND OLD.unit_code IS DISTINCT FROM NEW.unit_code THEN

    -- Update all manpower records linked to this team
    UPDATE public.manpower
    SET
      unit_code = NEW.unit_code,
      updated_at = now()  -- Explicitly update timestamp for cascade changes
    WHERE team_id = NEW.id;

    -- Log the number of affected records (optional - can be removed in production)
    RAISE NOTICE 'Updated % manpower records with new unit_code: %',
      ROW_COUNT, COALESCE(NEW.unit_code, 'NULL');
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.touch_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Check if the updated_at column exists in NEW record
  IF to_jsonb(NEW) ? 'updated_at' THEN
    NEW.updated_at = now();
  END IF;
  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- If there's any error, just return NEW without modification
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_update_annual_from_monthly()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Update both calendar and systems annual summaries when monthly data changes

    -- For INSERT/UPDATE operations
    IF TG_OP IN ('INSERT', 'UPDATE') THEN
        -- Update calendar annual summary
        PERFORM recalculate_annual_summary(
            NEW.advisor_code,
            NEW.period_year,
            'calendar'
        );

        -- Update systems annual summary
        PERFORM recalculate_annual_summary(
            NEW.advisor_code,
            NEW.period_year,
            'systems'
        );
    END IF;

    -- For UPDATE/DELETE operations (handle old values)
    IF TG_OP IN ('UPDATE', 'DELETE') THEN
        -- Update annual summary for old values (if different year)
        IF TG_OP = 'DELETE' OR OLD.period_year != NEW.period_year THEN
            PERFORM recalculate_annual_summary(
                OLD.advisor_code,
                OLD.period_year,
                'calendar'
            );

            PERFORM recalculate_annual_summary(
                OLD.advisor_code,
                OLD.period_year,
                'systems'
            );
        END IF;
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_update_summary_commission()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    cal_period RECORD;
    sys_period RECORD;
    affected_date date;
BEGIN
    affected_date := COALESCE(NEW.process_date, OLD.process_date);

    -- Update calendar summary
    SELECT * INTO cal_period FROM get_calendar_period(affected_date);
    IF cal_period IS NOT NULL THEN
        PERFORM recalculate_monthly_summary(
            COALESCE(NEW.code, OLD.code),
            cal_period.period_year,
            cal_period.period_month,
            'calendar',
            cal_period.period_start,
            cal_period.period_end
        );
    END IF;

    -- Update systems summary
    SELECT * INTO sys_period FROM get_systems_period(affected_date);
    IF sys_period IS NOT NULL THEN
        PERFORM recalculate_monthly_summary(
            COALESCE(NEW.code, OLD.code),
            sys_period.period_year,
            sys_period.period_month,
            'systems',
            sys_period.period_start,
            sys_period.period_end
        );
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_update_summary_settled_apps()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    cal_period RECORD;
    sys_period RECORD;
    affected_date date;
BEGIN
    -- Determine which date to use (NEW for INSERT/UPDATE, OLD for DELETE)
    affected_date := COALESCE(NEW.process_date, OLD.process_date);

    -- Get calendar period for this date
    SELECT * INTO cal_period FROM get_calendar_period(affected_date);

    -- Update calendar summary if period found
    IF cal_period IS NOT NULL THEN
        PERFORM recalculate_monthly_summary(
            COALESCE(NEW.advisor_code, OLD.advisor_code),
            cal_period.period_year,
            cal_period.period_month,
            'calendar',
            cal_period.period_start,
            cal_period.period_end
        );
    END IF;

    -- Get systems period for this date
    SELECT * INTO sys_period FROM get_systems_period(affected_date);

    -- Update systems summary if period found
    IF sys_period IS NOT NULL THEN
        PERFORM recalculate_monthly_summary(
            COALESCE(NEW.advisor_code, OLD.advisor_code),
            sys_period.period_year,
            sys_period.period_month,
            'systems',
            sys_period.period_start,
            sys_period.period_end
        );
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_update_summary_submitted_apps()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    cal_period RECORD;
    sys_period RECORD;
    affected_date date;
BEGIN
    affected_date := COALESCE(NEW.process_date, OLD.process_date);

    -- Update calendar summary
    SELECT * INTO cal_period FROM get_calendar_period(affected_date);
    IF cal_period IS NOT NULL THEN
        PERFORM recalculate_monthly_summary(
            COALESCE(NEW.advisor_code, OLD.advisor_code),
            cal_period.period_year,
            cal_period.period_month,
            'calendar',
            cal_period.period_start,
            cal_period.period_end
        );
    END IF;

    -- Update systems summary
    SELECT * INTO sys_period FROM get_systems_period(affected_date);
    IF sys_period IS NOT NULL THEN
        PERFORM recalculate_monthly_summary(
            COALESCE(NEW.advisor_code, OLD.advisor_code),
            sys_period.period_year,
            sys_period.period_month,
            'systems',
            sys_period.period_start,
            sys_period.period_end
        );
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_profiles_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Check if the updated_at column exists in NEW record
  IF to_jsonb(NEW) ? 'updated_at' THEN
    NEW.updated_at = now();
  END IF;
  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- If there's any error, just return NEW without modification
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upload_with_deduplication(p_table_name text, p_records jsonb, p_duplicate_fields text[])
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  records_inserted integer := 0;
  errors text[] := ARRAY[]::text[];
  record_item jsonb;
  i integer;
  insert_sql text;
  field_values text;
BEGIN
  -- Validate table name
  IF p_table_name NOT IN ('submitted_apps_details', 'settled_apps_details', 'fy_commission_details', 'rn_commission_details') THEN
    RETURN jsonb_build_object(
      'success', false,
      'duplicates_removed', 0,
      'records_inserted', 0,
      'errors', ARRAY['Invalid table name: ' || p_table_name]
    );
  END IF;

  -- Validate input
  IF p_records IS NULL OR jsonb_array_length(p_records) = 0 THEN
    RETURN jsonb_build_object(
      'success', false,
      'duplicates_removed', 0,
      'records_inserted', 0,
      'errors', ARRAY['No records provided']
    );
  END IF;

  -- Process records one by one to avoid bulk insert issues
  FOR i IN 0..jsonb_array_length(p_records)-1 LOOP
    record_item := p_records->i;

    BEGIN
      CASE p_table_name
        WHEN 'submitted_apps_details' THEN
          INSERT INTO submitted_apps_details (
            advisor_code, advisor_name, process_date, insured_name, policy_number, submitted_apps
          ) VALUES (
            record_item->>'advisor_code',
            record_item->>'advisor_name',
            (record_item->>'process_date')::date,
            record_item->>'insured_name',
            record_item->>'policy_number',
            (record_item->>'submitted_apps')::numeric
          );

        WHEN 'settled_apps_details' THEN
          INSERT INTO settled_apps_details (
            advisor_code, advisor_name, process_date, insured_name, policy_number,
            settled_apps, agency_credits, net_sales_credits
          ) VALUES (
            record_item->>'advisor_code',
            record_item->>'advisor_name',
            (record_item->>'process_date')::date,
            record_item->>'insured_name',
            record_item->>'policy_number',
            (record_item->>'settled_apps')::numeric,
            (record_item->>'agency_credits')::numeric,
            (record_item->>'net_sales_credits')::numeric
          );

        WHEN 'fy_commission_details' THEN
          INSERT INTO fy_commission_details (
            code, process_date, insured_name, policy_number, transaction_type, fy_premium_php, due_date, rate, fy_commission_php
          ) VALUES (
            record_item->>'code',
            (record_item->>'process_date')::date,
            record_item->>'insured_name',
            record_item->>'policy_number',
            record_item->>'transaction_type',
            (record_item->>'fy_premium_php')::numeric,
            (record_item->>'due_date')::date,
            (record_item->>'rate')::numeric,
            (record_item->>'fy_commission_php')::numeric
          );

        WHEN 'rn_commission_details' THEN
          INSERT INTO rn_commission_details (
            code, process_date, insured_name, policy_number, transaction_type, rn_premium_php, due_date, rate, year, rn_commission_php
          ) VALUES (
            record_item->>'code',
            (record_item->>'process_date')::date,
            record_item->>'insured_name',
            record_item->>'policy_number',
            record_item->>'transaction_type',
            (record_item->>'rn_premium_php')::numeric,
            (record_item->>'due_date')::date,
            (record_item->>'rate')::numeric,
            (record_item->>'year')::integer,
            (record_item->>'rn_commission_php')::numeric
          );
      END CASE;

      records_inserted := records_inserted + 1;

    EXCEPTION
      WHEN OTHERS THEN
        errors := errors || ('Record ' || (i + 1)::text || ' failed: ' || SQLERRM);
        CONTINUE;
    END;
  END LOOP;

  RETURN jsonb_build_object(
    'success', records_inserted > 0,
    'duplicates_removed', 0,  -- Not doing duplicate detection for now
    'records_inserted', records_inserted,
    'errors', COALESCE(errors, ARRAY[]::text[])
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'duplicates_removed', 0,
      'records_inserted', 0,
      'errors', ARRAY['Function error: ' || SQLERRM]
    );
END;
$function$
;


